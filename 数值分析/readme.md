# 这是数值分析，数学

## 一些数学方法的程序化实现

https://github.com/brightendavid/html_calculations

这个仓库还不够完善啊

* 我看出来了，我的笔记做得有点小问题，太过自由主义

# 误差分析

* 绝对误差,e(x*)

$$
s = x^* -x
$$

* 相对误差,符号为

  
  $$
  er(x^*)
  $$
  其中，x*为真实值，x为观测值

  
  $$
  s = (x^* -x)/x=dx/x
  $$

  ## 性质

  ![6727239a2db6e495e9ee88849252b40b](6727239a2db6e495e9ee88849252b40b.jpg)

* 乘积的相对误差限是各乘数的和

![13fa55a415614bbd573104a768c50b0c](13fa55a415614bbd573104a768c50b0c.jpg)

* 商的相对误差是两个变量的相对误差的差；相对误差限是和
* 进而，无论乘除，相对误差限都是和

![031ad06dc026ad6e4ced2b3b8394afa4](031ad06dc026ad6e4ced2b3b8394afa4.jpg)

* 变量经过函数f的误差，相当于被放缩了|f'|倍。注意，这里是e，不是er。是绝对误差
* er(x)和er(f(x))的转换公式

$$
er(f(x^*)) =e(f(x))/f(x)=(e(x^*)*f'(x^*))/f(x)=(x^**f'(x^*))/f(x)*er(x^*)
$$

![c1cf2f86995e01771188137367e7a8df](c1cf2f86995e01771188137367e7a8df.jpg)

* 扩展到多元函数和f的换算。**绝对误差是偏导*变量误差的和。**

![fcdf9f13aae1f27cbfd9115db7c6ad49](fcdf9f13aae1f27cbfd9115db7c6ad49.jpg)

> [!TIP]
>
> ![708200a8ab1d170cacbaa92c6ce7c42a](708200a8ab1d170cacbaa92c6ce7c42a.jpg)

## 误差的定性分析

病态问题和条件数
$$
er(y)/er(x)= (f-f^*)/f(x) / (detail x)/(x) = (x*f')/f(x)=条件数Cp
$$

* 避免两个相近的数相减

![d1eeef59ae3de1e3eeb8ea450a929913](d1eeef59ae3de1e3eeb8ea450a929913.jpg)

因为两个相近的数相减会把大的有效位去掉，解决方案是减法换加法

![4fa687c3e06dba32e2330d8bdcdcdc69](4fa687c3e06dba32e2330d8bdcdcdc69.jpg)

在计算过程中有这样几种运算，导致了相近的数相减。可以采用泰勒展开，或者其他手法把减法转化掉
$$
\sqrt{x-\varepsilon } -x,ln(x+\varepsilon)-ln(x)
$$


<img src="2c094ae222686510758699042bc940fc.jpg" alt="2c094ae222686510758699042bc940fc" style="zoom:50%;" />

使用法1和法2得到的精确位数不一样

* 防止大数吃小数。这个在计算机的运算上可以感受到。确定精确位数的计算机，5位有效位，50000+0.1=50000

* 避免除数的绝对值远小于被除数的绝对值,误差会被y*y放大很多倍

$$
e(x/y) = (x/y)'= (e(x)y+e(y)x)/y^2
$$

## 使用稳定的算法

* 多项式求解过程中使用秦九昭算法。秦九韶算法在数值计算中具有较好的稳定性，主要因为它能有效减少运算次数，从而降低舍入误差的积累。运算数是比直接计算要少很多的，可以减少计算过程中带来的误差递增效应。

$$
P(x)=a2*x(x(a1x+b1))+b2...
$$

* 迭代法求解开方运算。这样迭代过一遍会更加接近真实值

<img src="2fd0aa5ed7d06d55c304fd9dff9f3ecb.jpg" alt="2fd0aa5ed7d06d55c304fd9dff9f3ecb" style="zoom:50%;" />
$$
x* =x+\triangle x
$$

$$
\triangle x = (a-x^2)/(2x)
$$

$$
x= x+\triangle x=x+ (a-x^2)/(2x)
$$

* 以整化零，以直代曲。这主要还是微分或者说几何的思想。

<img src="1fc8fd18010a9e94633e0bfddd54a678.jpg" alt="1fc8fd18010a9e94633e0bfddd54a678" style="zoom:33%;" />



# 插值法

<img src="843a22b30fbb11855c2b8960252b806a.jpg" alt="843a22b30fbb11855c2b8960252b806a" style="zoom:25%;" />

解决构造严格经过n个点的函数问题。可以采用拉格朗日插值法，牛顿插值法。

## 定义

> [!NOTE]
>
> 如果是熟悉数学史，科学史的朋友可能知道，这样定义的数学语言，车轱辘话是为了精确表述这个概念的无奈之举，最初这个数学概念的定义是非常通俗的，例如定义一个连续的函数，最初的定义是“笔不离开纸就是连续函数”。这样的大白话确实是说人话了，但是不准确。所以定义是非常重要的。


$$
设y=f(x)在[a,b]上有定义，且存在a<=x0<x1<...<xn<=b,，且存在一个简单函数P(x),P(xi)=yi,(i=0,1,...n)(1.1).其中，点x0,x1...称为插值节点，[a,b]称为插值区间。(1.1)称为插值条件，求P(x)的方法称为插值法。
$$

## 使用多项式插值法

$$
即使用x,x^2,x^3等x的幂次对原函数进行拟合。P(x)=a0+a1x+a2x^2...+anx^n
$$

* 可以通过反证法证明，若插值节点i[0,n]互异，则次数不超过n的多项式存在且唯一。
* n+1个条件确定了n+1个未知数ai,i[0,n]
* 若不规定次数不超过n,则可能有多个解
* 可通过朴素的待定系数法去解方程，求得ai的数值。就是n+1个方程求n+1个未知数的问题。条件可能是导数。

<img src="6ed8b863b3cccf2fc569a02d5d40a096.jpg" alt="6ed8b863b3cccf2fc569a02d5d40a096" style="zoom:33%;" />

## 拉格朗日插值法

> [!IMPORTANT]
>
> 这个方法的基本思想就是构造基函数，和一些中国剩余定理里面的模运算的基向量的思想是一致的。

构造基函数li(xj)使得其满足以下性质
$$
\begin{array}{l} 
  \left\{\begin{matrix} 
  li(x_j)=1(i=j) \\ 
  li(x_j)=0(i!=j)
\end{matrix}\right.    
\end{array}
$$
使用矩阵描述就是一个（n,n）的单位矩阵。
$$
\begin{bmatrix}
1  & & \\
  & 1 & \\
  &  &1
\end{bmatrix}
$$
在图像上，li(x)表现为，在i!=j，严格穿过(xj,0)，在i点,严格穿过(xi,yi)。就可以通过这些li函数的线性叠加构造满足条件的函数L了。
$$
li(xi)=A(x-x_0)(x-x_1)(x-x_2)...(x-x_n)/(x-x_i),即,里面没有(x-x_i)这一项
$$

$$
要使得li(xi)=1,则A =(xi-x_0)(xi-x_1)(xi-x_2)...(xi-x_n)
$$



<section>
 <img src="1d2f0ed26f740e8a0eb5b02b82e94e1a.jpg"></img>
 <img src="427a314053f03544ded7e8b285303c30.jpg"></img>
</section>

如图所示，拉格朗日插值法就是这样多个基函数的线性组合,这个和余弦波的叠加是类似的
$$
L(x) =\sum_{i=0}^{n} y_i*l_i(x)
$$
由于基函数li(x)的性质，所以，满足性质
$$
L(x_m) = y_m
$$

> [!CAUTION]
>
> 请注意，这个方法本质上还是在做一个穿线的工作，一切都要围绕穿线来思考。例如：
>
> * 可以直接使用点斜式、两点式来表示出两点的方程
> * 三点一定是一个抛物线，或者抛物线的退化形式
> * 可以通过“插值多项式的唯一性”构造一个穿线的函数来证明一些性质

### 性质

* 无关性：基函数li(x)只和插值节点xi有关，和yi,被插函数f(x)无关。（这个性质还是比较好用的）

* 唯一性：构造一个y=1的直线，在上面取点，可以构造L(x)。由插值多项式的唯一性可以证明，可以通过特例获得一个普适的推论。


$$
L(x) =\sum_{i=0}^{n} l_i(x)=1
$$

* Ln(x)通常为n次多项式，特殊情况下可能小于n（共线导致的函数退化）

* 拉格朗日余项，n+1就是用到的插值节点的数量。这个余项对于之后的牛顿插值法也是相同的。请注意各项的下标，Rn是对Ln做误差估计，其他均为n+1.

$$
R_n(x)=f(x)-L_n(x)=f^{(n+1)}(\varepsilon)/（n+1）!*w_{n+1}(x)
$$

$$
w_{n+1}(x)=\prod_{0}^{n}(x-x_i)
$$

$$
对于\varepsilon,\varepsilon\in [a,b],可以采用取最大值的方式，得到一个误差的最大值，做一个不等式。这只是一个估计而已，在牛顿插值法里面可以用n+1阶查分估计它。
$$

可以通过罗尔中值定理证明，因为误差项肯定是带有w(n+1)这一项的。

<img src="42922b31d5159c94f506d0070babb66c.jpg" alt="42922b31d5159c94f506d0070babb66c" style="zoom:50%;" />

φ函数有n+2个零点，即由n+1阶导数，再求n+1阶导数即可。

* 由于误差R是n+1阶导数这个性质，所以对于x的k阶幂，k<n+1，R=0，估计是无偏的。所以x的k阶幂采用拉格朗日插值法做，就是原值。

* 名词解释：线性插值就是拉格朗日一次插值，二次插值就是拉格朗日二次插值。不是什么多项式插值。

<img src="b2b3a423547782168db87a1f405cd86d.jpg" alt="b2b3a423547782168db87a1f405cd86d" style="zoom:33%;" />

所以说，思路打开，拉格朗日插值法和之前的直接给它拟合到一个函数是共用的。

## 差商和牛顿插值



### 差商

$$
f[x0,x1]=(f(x0)-f(x1)) /(x0-x1)
$$

差商可以继续向下定义，
$$
f[x0,x1,...,xn]=(f[x0,x1...,x_{n-1}]-f[x1,x2,...x_{n}])/(x_0-x_{n})
$$
n阶差商可以由n-1阶差商定义，计算。可以通过构造插商表辅助计算。

|      | f    | 一阶     | 二阶        | 三阶 |
| ---- | ---- | -------- | ----------- | ---- |
| x0   | fx0  | f[x0,x1] | f[x0,x1,x2] |      |
| x1   | fx1  | f[x1,x2] |             |      |
| x2   | fx2  |          |             |      |

#### 性质

* 差商可以表示为函数值的线性组合，可以通过数学归纳法证明

$$
f[x0,x1,..,xn]=\sum_{k=0}^{n}\frac{f(x_{k})}{\prod_{i=0}^{n}  (x_{k}-x_i)}
$$

* 差商和节点的排列词序无关
* 通过拉格朗日中值定理可证，

$$
f[x0,x1...,xn]=\frac{ f^{(n)}(\varepsilon )}{n!}
$$

* 若f(x)是n次多项式，f[x0,x1...xk]是n-k次多项式。k>n时，为0次多项式

<img src="0853dc3801ca48348bdaba0d41a178b8.jpg" alt="0853dc3801ca48348bdaba0d41a178b8" style="zoom:50%;" />

8次多项式求8阶差商，就只剩下一个系数了。求9阶差商，必然是0

### 牛顿插值法

通过对差商的一些数学变换，就可以得到牛顿插值法公式。和拉格朗日插值法相比，优点在于，新加入一个点，可以在原式基础上，通过简单的添加一项，就可以了。不需要重新再算一遍基函数。

<img src="24dfc0fc948bbfe860c0e2659614227a.jpg" alt="24dfc0fc948bbfe860c0e2659614227a" style="zoom:50%;" />

* 牛顿插值法的余项和拉格朗日插值法的余项是一致的。

$$
R_{n-1}=N_n(x) -N_{n-1}(x)=f[x0,x1,...x_n](x-x0)(x-x1)...(x-x_n)
$$

$$
f[x0,x1...,xn]=\frac{ f^{(n)}(\varepsilon )}{n!}
$$

得到的余项是相同的。上式，计算的是R(n-1),所以才是n啊，不要搞错了。





